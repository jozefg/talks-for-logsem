\documentclass[usenames,dvipsnames,aspectratio=169,12pt]{beamer}
\usepackage{tikz}
\usetikzlibrary{tikzmark,positioning}
\usepackage[customcolors]{hf-tikz}
\usepackage{microtype}
\usepackage{amsmath,amssymb,mathpartir,stmaryrd}
\usepackage[style=alphabetic,backref=true,maxbibnames=1000,natbib=true]{biblatex}
\usepackage{wasysym}
\usepackage{textcomp}
\usepackage[normalem]{ulem}
\usepackage{listings}
\usepackage{color}
\usepackage{xparse}
\usepackage{newtxmath}
\usepackage[nameinlink,capitalize,noabbrev]{cleveref}

\definecolor{JadeGreen}{RGB}{0,168,107}
\definecolor{MunsellPurple}{RGB}{159,0,197}
\definecolor{LightGrey}{gray}{0.9}
\definecolor{CobaltBlue}{RGB}{0,71,171}
\definecolor{FireBrick}{RGB}{228,34,23}
\definecolor{Alabaster}{RGB}{250,250,250}

\usetheme[numbering=counter]{metropolis}
\setbeamertemplate{navigation symbols}{}
\setbeamertemplate{itemize items}{$\bullet$}

\NewDocumentCommand{\Arr}{m m}{#1 \to #2}
\NewDocumentCommand{\Fun}{m m}{\mathsf{fun}\, #1 \Rightarrow #2}
\NewDocumentCommand{\App}{m m}{#1(#2)}
\NewDocumentCommand{\Nat}{}{\mathsf{Nat}}
\NewDocumentCommand{\Zero}{}{\mathsf{zero}}
\NewDocumentCommand{\Succ}{m}{\mathsf{succ}(#1)}
\NewDocumentCommand{\Vect}{m m}{\mathsf{Vec}(#1, #2)}
\NewDocumentCommand{\Nil}{}{\mathsf{nil}}
\NewDocumentCommand{\Cons}{m m}{#1 {:} #2}
\NewDocumentCommand{\Lang}{m}{\mathsf{#1}}

\NewDocumentCommand{\Nf}{m m}{\llbracket #1 : #2 \rrbracket}

\title{Implementing a Modal Dependent Type Theory}
\author{\textbf{Daniel Gratzer}\inst{1} \and Jonathan Sterling\inst{2} \and Lars Birkedal\inst{1}}
\institute{\inst{1} This University \smiley{} \\ \inst{2} Not This University \frownie{}}
\date{May 24, 2019}

\begin{document}
\begin{frame}[noframenumbering]
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{Hello!}
  First things first, the title of this talk is a lie.
  \pause

  \begin{itemize}
  \item I don't want to talk about \emph{modal} dependent type theory.
  \item I'd like to talk about the core idea behind this work.
  \end{itemize}
  \pause
  \bigskip

  An alternative title:
  \begin{center}
    \Large\bf
    Implementing Type Theory
  \end{center}

\end{frame}

\begin{frame}
  \frametitle{Some terminology}
  Languages classify expressions into different \emph{types}
  (\texttt{\textcolor{CobaltBlue}{int}},
  \texttt{\textcolor{CobaltBlue}{string}},
  \texttt{\textcolor{CobaltBlue}{char}}).
  \pause

  \begin{description}
  \item[Type System] The rules for what expressions belong to which types.
  \item[Type-Checker] The program that makes sure we follow the rules.
  \end{description}

\end{frame}

\begin{frame}
  \frametitle{Setting the Scene}

  What is type theory? Type theory is a....
  \begin{itemize}
  \setbeamercolor{itemize item}{fg=CobaltBlue}
  \item programming language with a rich type system.
  \setbeamercolor{itemize item}{fg=red}
  \item framework for reasoning about mathematical objects.

  \end{itemize}
  \pause
  \bigskip


  Each viewpoint induces requirements on a good type theory.
\end{frame}

\begin{frame}
  \frametitle{The Fundamental Tension}

  We want a type theory which is suitable for

  \begin{center}
    \textcolor{Red}{studying mathematics}
  \end{center}

  but at the same time still serves as setting for

  \begin{center}
    \textcolor{Blue}{programming}
  \end{center}

\end{frame}

\begin{frame}
  \frametitle{A Concrete Issue}
  Set aside the questions of \textcolor{Red}{mathematics} and \textcolor{Blue}{programming} for a
  second.
  \bigskip

  Type theory has functions
  \[
    \App{f\tikzmark{fun}}{a\tikzmark{arg}}
  \]
  \onslide<1>{When is this application well-typed?}
  \begin{tikzpicture}[
    remember picture,
    overlay,
    expl/.style={draw=Alabaster,fill=orange!30,rounded corners,text width=3cm},
    arrow/.style={RoyalBlue!80!black,ultra thick,->,>=latex}
    ]
    \node<2->[expl]
    (funex)
    at (-3,-0.75cm)
    {must have type $\Arr{A}{B}$};
    \node<3->[expl]
    (argex)
    at (3,-0.75cm)
    {must have type $C$};
    \node<4->
    at (0, -1.75cm)
    {\textbf{We must also have $A = C$!}};
    \draw<2->[arrow]
    (funex) to ([xshift=-1ex,yshift=-0.5ex]{pic cs:fun});
    \draw<3->[arrow]
    (argex) to ([xshift=0ex,yshift=-0.5ex]{pic cs:arg});
  \end{tikzpicture}
\end{frame}

\begin{frame}
  \frametitle{How hard is type-checking?}
  What should we take away from this example?
  \begin{enumerate}
  \item In order to type-check, we must check if two types are equal.
  \item We need a program checking type equality.
  \end{enumerate}
\end{frame}

\begin{frame}
  \frametitle{Just type equality?}
  Deciding type equality is always a problem but we have fancier types:
  \[
    \Vect{A}{n} \qquad\quad\qquad\quad\text{A list of $A$s of length $n$}
  \]
  \pause
  We don't just need type equality... we need term equality too!
\end{frame}

\begin{frame}
  \frametitle{The mess we're in}
  In order to implement type theory we must check the equality of terms.
  \begin{enumerate}
  \item So this is completely impossible in a Turing-complete language\footnote{Python, Java, C,
      C++, PostScript, and Magic the Gathering are all Turing-complete}.
  \item Actually it's impossible in many Turing-\emph{incomplete} languages as well.
  \item Many equalities we expect are impossible to automatically check:
    \[
      f = g \iff \text{for all } x,\ \App{f}{x} = \App{g}{x}
    \]
  \end{enumerate}
\end{frame}

\begin{frame}
  \frametitle{Modern Type Theory}
  The central balancing act is then defining an equality relation which is
  \begin{itemize}
  \item strong enough to match our \textcolor{Red}{mathematical} intuitions.
  \item simple enough that we can \textcolor{Blue}{implement} it.
  \end{itemize}
  \bigskip

  Our work focused on experimenting with this balance for \emph{modal type theory}.
\end{frame}

% \begin{frame}
%   \frametitle{My Only Technical Slide, Promise}

%   The way that we prove decidability of equality is normalization.
%   \begin{theorem}[Normalization]
%     There exists a function $\Nf{M}{A}$ satisfying the following properties:
%     \begin{itemize}
%     \item $\Nf{M}{A}$ is identical to $\Nf{N}{A}$ if $M = N : A$
%     \item $\Nf{M}{A} = M : A$
%     \item $\Nf{\Nf{M}{A}}{A}$ is identical to $\Nf{M}{A}$
%     \end{itemize}
%   \end{theorem}
% \end{frame}

\begin{frame}
  \frametitle{Conclusions (some of the stuff I skipped)}
  I cut out a lot of cool stuff in this talk:
  \begin{itemize}
  \item Using type theory, we can ``run'' proofs math.
  \item We can use computer science to explore mathematics.
  \item We can use maths to inspire better PLs.
  \item Many unexplored and interesting questions remain.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Conclusions (the logsem group)}
  If this sounds interesting, please come talk to us!
  \begin{figure}
    \begin{tabular}{ccccc}
    {\includegraphics[height = 0.5in]{aslan.jpg}}      &
    {\includegraphics[height = 0.5in]{lars.jpg}}       &
    {\includegraphics[height = 0.5in]{bas.jpg}}        &
    {\includegraphics[height = 0.5in]{jaco.jpg}}       &
    {\includegraphics[height = 0.5in]{danil.jpg}}     \\
    {\includegraphics[height = 0.5in]{sabine.jpg}}     &
    {\includegraphics[height = 0.5in]{alix.png}}       &
    {\includegraphics[height = 0.5in]{kristoffer.jpg}} &
    {\includegraphics[height = 0.5in]{johan.jpg}}      &
    {\includegraphics[height = 0.5in]{martin.png}}    \\
    {\includegraphics[height = 0.5in]{jeppe.png}}      &
    {\includegraphics[height = 0.5in]{aina.png}}       &
    {\includegraphics[height = 0.5in]{jakob.png}}      &
    {\includegraphics[height = 0.5in]{marit.png}}      &
    {\includegraphics[height = 0.5in]{mathias.jpg}}   \\
                                                       &
    {\includegraphics[height = 0.5in]{lau.jpg}}        &
    {\includegraphics[height = 0.5in]{soeren.jpg}}     &
    {\includegraphics[height = 0.5in]{me.jpg}}         &
    \end{tabular}
  \end{figure}
\end{frame}

\end{document}
